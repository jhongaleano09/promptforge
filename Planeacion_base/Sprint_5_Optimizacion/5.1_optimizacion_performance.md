# Tarea 5.1: OptimizaciÃ³n de Performance

## ðŸŸ  PRIORIDAD ALTA

## Objetivo
Optimizar performance de backend y frontend para producciÃ³n.

## Backend Optimizations

### 1. Database
- Agregar Ã­ndices a columnas frecuentemente consultadas
- Optimizar queries N+1
- Connection pooling adecuado

```python
# Agregar Ã­ndices
class APIKey(Base):
    provider = Column(String(50), index=True)  # â† Agregar index
    is_active = Column(Boolean, index=True)
```

### 2. Caching
- Cachear lista de modelos disponibles
- Cachear respuestas de validaciÃ³n (con TTL corto)

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_available_models(provider: str):
    # ...
```

### 3. Async Optimization
- Asegurar que todas las llamadas a LLM son async
- No bloquear event loop

## Frontend Optimizations

### 1. Code Splitting
```tsx
// Lazy load componentes pesados
const SettingsPage = dynamic(() => import('./settings/page'), {
  loading: () => <LoadingState />
});
```

### 2. Bundle Size
```bash
# Analizar bundle
npm run build
npx @next/bundle-analyzer

# Optimizar imports
import { Button } from '@/components/ui/button'  # âœ…
import * as UI from '@/components/ui'            # âŒ
```

### 3. Image Optimization
- Usar Next.js Image component
- Lazy load images
- WebP format

### 4. Memoization
```tsx
const expensiveCalculation = useMemo(() => {
  return calculateTokens(messages);
}, [messages]);
```

## Criterios de Ã‰xito
- [ ] Lighthouse score > 90
- [ ] Time to Interactive < 3s
- [ ] Bundle size < 500KB (gzipped)
- [ ] API response time < 200ms (sin LLM call)

âš ï¸ Actualizar PROGRESS.md al completar
