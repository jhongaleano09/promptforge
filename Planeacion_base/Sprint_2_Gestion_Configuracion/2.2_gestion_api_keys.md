# Tarea 2.2: Gesti贸n de M煤ltiples API Keys

##  PRIORIDAD ALTA

## Objetivo
Implementar sistema CRUD para gestionar m煤ltiples API keys por proveedor, con encriptaci贸n segura, validaci贸n, y UI intuitiva.

## Estado Actual
- Solo se puede configurar una API key
- Key se almacena en settings (posiblemente sin encriptaci贸n robusta)
- No hay UI para gestionar m煤ltiples keys

## Arquitectura Propuesta

### Modelo de Datos
```sql
CREATE TABLE api_keys (
    id INTEGER PRIMARY KEY,
    provider VARCHAR(50) NOT NULL,
    key_name VARCHAR(100),  -- "OpenAI Personal", "OpenAI Work", etc.
    api_key_encrypted BLOB NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used_at TIMESTAMP,
    UNIQUE(provider, key_name)
);
```

## Pasos de Implementaci贸n

### Paso 1: Modelo de Base de Datos

**Modificar**: `backend/app/db/models.py`

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, LargeBinary
from sqlalchemy.sql import func
from .database import Base

class APIKey(Base):
    __tablename__ = "api_keys"
    
    id = Column(Integer, primary_key=True, index=True)
    provider = Column(String(50), nullable=False)
    key_name = Column(String(100))
    api_key_encrypted = Column(LargeBinary, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    last_used_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    class Config:
        from_attributes = True
```

### Paso 2: Servicio de Encriptaci贸n

**Crear**: `backend/app/services/encryption.py`

```python
from cryptography.fernet import Fernet
import base64
import os
from typing import Optional

class EncryptionService:
    """Servicio para encriptar/desencriptar API keys"""
    
    def __init__(self):
        # Obtener clave de encriptaci贸n desde env
        encryption_key = os.getenv("ENCRYPTION_KEY")
        
        if not encryption_key:
            # Generar nueva clave si no existe (solo desarrollo)
            encryption_key = Fernet.generate_key().decode()
            print(f"锔  ENCRYPTION_KEY no encontrada. Usando: {encryption_key}")
            print("Agregar a .env para producci贸n")
        
        self.fernet = Fernet(encryption_key.encode())
    
    def encrypt(self, plaintext: str) -> bytes:
        """Encriptar texto plano"""
        return self.fernet.encrypt(plaintext.encode())
    
    def decrypt(self, encrypted: bytes) -> str:
        """Desencriptar a texto plano"""
        return self.fernet.decrypt(encrypted).decode()
    
    def mask_key(self, api_key: str, visible_chars: int = 4) -> str:
        """Enmascarar API key para mostrar en UI"""
        if len(api_key) <= visible_chars * 2:
            return '*' * len(api_key)
        
        return f"{api_key[:visible_chars]}...{api_key[-visible_chars:]}"

# Singleton
encryption_service = EncryptionService()
```

### Paso 3: Endpoints CRUD

**Crear**: `backend/app/api/api_keys.py`

```python
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from typing import List
from pydantic import BaseModel

from app.db.database import get_db
from app.db.models import APIKey
from app.services.encryption import encryption_service
from app.services.providers.manager import ProviderManager
from app.services.providers.base import ProviderConfig

router = APIRouter(prefix="/api-keys", tags=["api-keys"])

class APIKeyCreate(BaseModel):
    provider: str
    key_name: str
    api_key: str

class APIKeyResponse(BaseModel):
    id: int
    provider: str
    key_name: str
    api_key_masked: str
    is_active: bool
    created_at: str
    
    class Config:
        from_attributes = True

@router.post("/", response_model=APIKeyResponse)
async def create_api_key(
    key_data: APIKeyCreate,
    db: Session = Depends(get_db)
):
    """Crear nueva API key"""
    
    # Validar provider existe
    try:
        ProviderManager.get_provider(key_data.provider, ProviderConfig(
            api_key="dummy", model="dummy"
        ))
    except ValueError:
        raise HTTPException(status_code=400, detail="Provider no soportado")
    
    # Validar API key
    try:
        config = ProviderConfig(api_key=key_data.api_key, model="dummy")
        provider = ProviderManager.get_provider(key_data.provider, config)
        
        # Obtener primer modelo disponible
        models = provider.get_available_models()
        if models:
            config.model = models[0].id
            provider = ProviderManager.get_provider(key_data.provider, config)
            is_valid = await provider.validate_api_key()
            
            if not is_valid:
                raise HTTPException(status_code=400, detail="API key inv谩lida")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error validando key: {str(e)}")
    
    # Encriptar
    encrypted_key = encryption_service.encrypt(key_data.api_key)
    
    # Guardar
    db_key = APIKey(
        provider=key_data.provider,
        key_name=key_data.key_name,
        api_key_encrypted=encrypted_key,
        is_active=True
    )
    
    db.add(db_key)
    db.commit()
    db.refresh(db_key)
    
    return APIKeyResponse(
        id=db_key.id,
        provider=db_key.provider,
        key_name=db_key.key_name,
        api_key_masked=encryption_service.mask_key(key_data.api_key),
        is_active=db_key.is_active,
        created_at=db_key.created_at.isoformat()
    )

@router.get("/", response_model=List[APIKeyResponse])
async def list_api_keys(db: Session = Depends(get_db)):
    """Listar todas las API keys"""
    keys = db.query(APIKey).all()
    
    return [
        APIKeyResponse(
            id=key.id,
            provider=key.provider,
            key_name=key.key_name,
            api_key_masked=encryption_service.mask_key(
                encryption_service.decrypt(key.api_key_encrypted)
            ),
            is_active=key.is_active,
            created_at=key.created_at.isoformat()
        )
        for key in keys
    ]

@router.delete("/{key_id}")
async def delete_api_key(key_id: int, db: Session = Depends(get_db)):
    """Eliminar API key"""
    key = db.query(APIKey).filter(APIKey.id == key_id).first()
    
    if not key:
        raise HTTPException(status_code=404, detail="API key no encontrada")
    
    db.delete(key)
    db.commit()
    
    return {"message": "API key eliminada"}

@router.patch("/{key_id}/toggle")
async def toggle_api_key(key_id: int, db: Session = Depends(get_db)):
    """Activar/desactivar API key"""
    key = db.query(APIKey).filter(APIKey.id == key_id).first()
    
    if not key:
        raise HTTPException(status_code=404, detail="API key no encontrada")
    
    key.is_active = not key.is_active
    db.commit()
    
    return {"is_active": key.is_active}
```

### Paso 4: Frontend - API Key Manager

**Crear**: `frontend/src/components/settings/ApiKeyManager.tsx`

```typescript
'use client';

import { useState, useEffect } from 'react';
import { useToastStore } from '@/components/ui/ToastContainer';

interface ApiKey {
  id: number;
  provider: string;
  key_name: string;
  api_key_masked: string;
  is_active: boolean;
  created_at: string;
}

export default function ApiKeyManager({ provider }: { provider: string }) {
  const [keys, setKeys] = useState<ApiKey[]>([]);
  const [showAddForm, setShowAddForm] = useState(false);
  const [newKey, setNewKey] = useState({ key_name: '', api_key: '' });
  const [loading, setLoading] = useState(false);
  const { addToast } = useToastStore();

  useEffect(() => {
    fetchKeys();
  }, []);

  const fetchKeys = async () => {
    try {
      const response = await fetch('/api/api-keys');
      const data = await response.json();
      setKeys(data.filter((k: ApiKey) => k.provider === provider));
    } catch (error) {
      console.error('Error fetching keys:', error);
    }
  };

  const handleAddKey = async () => {
    if (!newKey.key_name || !newKey.api_key) {
      addToast({ type: 'error', message: 'Completa todos los campos' });
      return;
    }

    setLoading(true);
    try {
      const response = await fetch('/api/api-keys', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          provider,
          key_name: newKey.key_name,
          api_key: newKey.api_key
        })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail);
      }

      addToast({ type: 'success', message: 'API key agregada correctamente' });
      setNewKey({ key_name: '', api_key: '' });
      setShowAddForm(false);
      fetchKeys();
    } catch (error: any) {
      addToast({ type: 'error', message: error.message });
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteKey = async (keyId: number) => {
    if (!confirm('驴Eliminar esta API key?')) return;

    try {
      await fetch(`/api/api-keys/${keyId}`, { method: 'DELETE' });
      addToast({ type: 'success', message: 'API key eliminada' });
      fetchKeys();
    } catch (error) {
      addToast({ type: 'error', message: 'Error eliminando key' });
    }
  };

  const handleToggleKey = async (keyId: number) => {
    try {
      await fetch(`/api/api-keys/${keyId}/toggle`, { method: 'PATCH' });
      fetchKeys();
    } catch (error) {
      addToast({ type: 'error', message: 'Error actualizando key' });
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-medium">API Keys - {provider}</h3>
        <button
          onClick={() => setShowAddForm(!showAddForm)}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          + Agregar Key
        </button>
      </div>

      {showAddForm && (
        <div className="p-4 border rounded bg-gray-50 space-y-3">
          <input
            type="text"
            placeholder="Nombre (ej: OpenAI Personal)"
            value={newKey.key_name}
            onChange={(e) => setNewKey({ ...newKey, key_name: e.target.value })}
            className="w-full px-3 py-2 border rounded"
          />
          <input
            type="password"
            placeholder="API Key"
            value={newKey.api_key}
            onChange={(e) => setNewKey({ ...newKey, api_key: e.target.value })}
            className="w-full px-3 py-2 border rounded"
          />
          <div className="flex gap-2">
            <button
              onClick={handleAddKey}
              disabled={loading}
              className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
            >
              {loading ? 'Validando...' : 'Guardar'}
            </button>
            <button
              onClick={() => setShowAddForm(false)}
              className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
            >
              Cancelar
            </button>
          </div>
        </div>
      )}

      <div className="space-y-2">
        {keys.map((key) => (
          <div
            key={key.id}
            className="flex items-center justify-between p-3 border rounded"
          >
            <div className="flex-1">
              <div className="font-medium">{key.key_name}</div>
              <div className="text-sm text-gray-500 font-mono">
                {key.api_key_masked}
              </div>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => handleToggleKey(key.id)}
                className={`px-3 py-1 rounded text-sm ${
                  key.is_active
                    ? 'bg-green-100 text-green-700'
                    : 'bg-gray-100 text-gray-700'
                }`}
              >
                {key.is_active ? 'Activa' : 'Inactiva'}
              </button>
              <button
                onClick={() => handleDeleteKey(key.id)}
                className="px-3 py-1 bg-red-100 text-red-700 rounded text-sm hover:bg-red-200"
              >
                Eliminar
              </button>
            </div>
          </div>
        ))}
      </div>

      {keys.length === 0 && !showAddForm && (
        <div className="text-center py-8 text-gray-500">
          No hay API keys configuradas
        </div>
      )}
    </div>
  );
}
```

## Criterios de xito

- [ ] API keys encriptadas en base de datos
- [ ] CRUD completo funciona correctamente
- [ ] Validaci贸n de keys al agregar
- [ ] UI muestra keys enmascaradas
- [ ] Puede activar/desactivar keys
- [ ] Puede eliminar keys
- [ ] Toast notifications en acciones

## Notas Importantes

锔 **SEGURIDAD CRTICA**: 
- NUNCA loguear API keys completas
- Generar ENCRYPTION_KEY 煤nico para producci贸n
- Agregar a `.env` y `.gitignore`

 **MIGRATION**: Crear migraci贸n de DB:
```bash
alembic revision -m "add_api_keys_table"
```

 **PROGRESS.md**: Actualizar al completar tarea 2.2
